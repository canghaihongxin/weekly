# 可见性、有序性、原子性问题

并发编程有什么用？ 毋庸置疑是为了挖掘服务器的潜力，提升程序的性能。但是这又给我们带来了新的问题。

- 多核CPU 增加了缓存，以均衡与内存的速度差异；导致 `可见性`问题

- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。导致 `有序性`问题
- 进程，线程，分时使用CPU, 以均衡CPU与I/O之间的差异。导致了数据的`原子性`



学习使用并发编程就是既要提升性能，同时又要避免上面的问题。 

## 可见性问题



每颗CPU都有自己的缓存，多个线程在不同的CPU上执行时，这些线程操作的是不同的CPU缓存。比如下图中，线程A操作的是CPU-1上的缓存，而线程B操作的是CPU-2上的缓存，很明显，这个时候线程A对变量V的操作对于线程B而言就不具备可见性了

![](https://hutool-weekly.oss-cn-hangzhou.aliyuncs.com/img/20230530163030.png)



下面用代码的方式将可见性问题复现



我们使用for循环的方式创建多个线程去操作同一个变量`cnt` 。

```java
package com.bdf.juc.visibility;

import cn.hutool.core.thread.ThreadUtil;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadUnsafeExample {

    private int cnt = 0;

    public void add() {
        cnt++;
    }

    public int get() {
        return cnt;
    }

    public static void main(String[] args) throws InterruptedException {
        final int threadSize = 1000;
        ThreadUnsafeExample example = new ThreadUnsafeExample();
        final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
        ExecutorService executorService = ThreadUtil.newExecutor();
        for (int i = 0; i < threadSize; i++) {
            executorService.execute(() -> {
                example.add();
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        System.out.println(example.get());

    }

}

```

输出结果 

```
986
```

期望的输出结果是1000。可是最终的输出结果是变化的， 总是达不到1000。 

线程是在CPU里面运行的，会将线程需要运行的数据拉到CPU的缓存中运算。多个CPU就会有多个缓存。 这里就是将CNT拉取到不同的缓存中， 每一个线程都在自己的缓存中操作，操作完成之后在同步到内存中。 

这样当线程A和线程B都去内存中读取CNT，读取到的值都是1，  并将CNT改写成2，写到内存中。此时正确实的值应该是3，可是最终内存中的值是2。 这就是可见性问题。 



# 原子性问题





































