import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,f as p}from"./app-485579f8.js";const e={},t=p(`<h1 id="可见性、有序性、原子性问题" tabindex="-1"><a class="header-anchor" href="#可见性、有序性、原子性问题" aria-hidden="true">#</a> 可见性、有序性、原子性问题</h1><p>并发编程有什么用？ 毋庸置疑是为了挖掘服务器的潜力，提升程序的性能。但是这又给我们带来了新的问题。</p><ul><li><p>多核CPU 增加了缓存，以均衡与内存的速度差异；导致 <code>可见性</code>问题</p></li><li><p>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。导致 <code>有序性</code>问题</p></li><li><p>进程，线程，分时使用CPU, 以均衡CPU与I/O之间的差异。导致了数据的<code>原子性</code></p></li></ul><p>学习使用并发编程就是既要提升性能，同时又要避免上面的问题。</p><h2 id="可见性问题" tabindex="-1"><a class="header-anchor" href="#可见性问题" aria-hidden="true">#</a> 可见性问题</h2><p>每颗CPU都有自己的缓存，多个线程在不同的CPU上执行时，这些线程操作的是不同的CPU缓存。比如下图中，线程A操作的是CPU-1上的缓存，而线程B操作的是CPU-2上的缓存，很明显，这个时候线程A对变量V的操作对于线程B而言就不具备可见性了</p><figure><img src="https://hutool-weekly.oss-cn-hangzhou.aliyuncs.com/img/20230530163030.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>下面用代码的方式将可见性问题复现</p><p>我们使用for循环的方式创建多个线程去操作同一个变量<code>cnt</code> 。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>bdf<span class="token punctuation">.</span>juc<span class="token punctuation">.</span>visibility</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">cn<span class="token punctuation">.</span>hutool<span class="token punctuation">.</span>core<span class="token punctuation">.</span>thread<span class="token punctuation">.</span></span><span class="token class-name">ThreadUtil</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ExecutorService</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadUnsafeExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadUnsafeExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadUnsafeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">ThreadUtil</span><span class="token punctuation">.</span><span class="token function">newExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>986
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>期望的输出结果是1000。可是最终的输出结果是变化的， 总是达不到1000。</p><p>线程是在CPU里面运行的，会将线程需要运行的数据拉到CPU的缓存中运算。多个CPU就会有多个缓存。 这里就是将CNT拉取到不同的缓存中， 每一个线程都在自己的缓存中操作，操作完成之后在同步到内存中。</p><p>这样当线程A和线程B都去内存中读取CNT，读取到的值都是1， 并将CNT改写成2，写到内存中。此时正确实的值应该是3，可是最终内存中的值是2。 这就是可见性问题。</p><h2 id="原子性问题" tabindex="-1"><a class="header-anchor" href="#原子性问题" aria-hidden="true">#</a> 原子性问题</h2><p>首先要明确的一点是多线程的原子性和数据库的原子性类似，但不是一回事。</p><p>多线程开发的原子性是指的 <strong>一个或者多个操作在CPU执行的过程中不被中断的特性称为原子性</strong>。 一个操作是CPU的一条指令。</p><p>数据库的原子性是事务不可分割，事务中的逻辑要么全部成功要么全部失败。 事务中的逻辑可以交由多个线程去实现。</p><p>在java代码中一个简单的语句也需要CPU中多条指令来完成。 例如: count+=1这个操作。</p><figure><img src="https://hutool-weekly.oss-cn-hangzhou.aliyuncs.com/img/20230605175557.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通常来说一个java语句去操作一个变量，同时这个语句使用多个线程运行， 是会有原子性问题的。 因为这是有很多个CPU指令去完成的。</p><p>怎么来保证线程的切换不影响我们的业务，这就需要一些高级语言给我们提供的一些工具。 至于什么工具，怎么用这些工具? 我们会在后面讲。</p><h2 id="有序性问题" tabindex="-1"><a class="header-anchor" href="#有序性问题" aria-hidden="true">#</a> 有序性问题</h2><p>我们在写代码的时候是按照一定的顺序来写的，也希望代码有顺序的执行。 但是在编译器执行代码的时候并不是按照顺序来执行。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              
<span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
i <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>                <span class="token comment">//语句1  </span>
flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token comment">//语句2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>语句1和语句2一定是先执行 语句1和语句2吗？ 不一定。 在程序执行是为了提高性能，编译器和处理器会对指令进行重新排序。</p><p>一个经典的单例问题， 其中只分析当有序性可能会引发的问题。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 ／／节点<span class="token class-name">B</span>
      <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先需要知道 <code>instance = new Singleton();</code> 这个语句是由多个命令组成：</p><ol><li>分配一块内存M</li><li>在内存M上初始化Singleton对象。</li><li>然后M的地址赋值给instance变量。</li></ol><p>假设有两个线程A、B调用getInstance()方法，线程A获取到了锁，开始执行创建对象语句。 而因为指令重排序。 <code>instance = new Singleton();</code> 的命令顺序有所改变（假设！ 不确定！ 有可能会变成下面说的那样）</p><ol><li>分配一块内存M；</li><li><strong>将M的地址赋值给instance变量；</strong></li><li>最后在内存M上初始化Singleton对象。</li></ol><p>而当创建对象指令执行到第二步时并且 线程B执行到第一个<code>if (instance == null) { </code> 代码中节点B时。 线程B执行这个判断语句会得到false,最终会得到一个instance对象，而这个instance对象还没有创建。 如果这个时候使用就会空指针。</p>`,34),c=[t];function o(l,i){return s(),a("div",null,c)}const d=n(e,[["render",o],["__file","可见性，有序性，原子性的问题.html.vue"]]);export{d as default};
